const XLSX = require('xlsx');
const verifyRoles = require('../auth/role-verification');
const getUniqueInArray = require('../util/getUniqueInArray');
const getTown = require('../util/getTown');
const calculateDistance = require('../util/calculateDistance');
const addCreatedAndModified = require('../util/addCreatedAndModified');

const service = {};

service.exportDB = async (modelsService, user, townIdOrName) => {
  if (!verifyRoles(['A'], user)) {
    return { statusCode: 401, data: 'Unauthorized' };
  }
  const townId = await getTown(modelsService, townIdOrName);
  if (!townId) {
    return { statusCode: 404, data: 'Town not found' };
  }
  const stations = await modelsService.getModel('Station')
    .find({ town: townId })
    .sort('name')
    .select('name geometry year yearEnd');
  try {
    const book = XLSX.utils.book_new();
    // Stations
    const stationsSheet = XLSX.utils.json_to_sheet(stations.map(s => {
      return {
        name: s.name,
        year: s.year,
        yearEnd: s.yearEnd,
        lat: s.geometry.coordinates[0],
        lng: s.geometry.coordinates[1]
      }
    }));
    XLSX.utils.book_append_sheet(book, stationsSheet, 'Stations');
    // Lines
    const lines = await modelsService.getModel('Line')
      .find({ town: townId })
      .sort('order')
      .select('order key name shortName colour fontColour year connections')
      .populate({ path: 'connections', sort: 'order', populate: { path: 'stations', select: 'name' } });
    lines.map(l => {

      const line_data = [
        ['order', 'key', 'name', 'shortName', 'colour', 'fontColour', 'lineyear', '', 'station_from', 'station_to', 'connectionYear', 'connectionYearEnd'],
        [l.order, l.key, l.name, l.shortName, l.colour, l.fontColour, l.year],
        [],
      ];

      l.connections.map(c => {
        line_data.push(['', '', '', '', '', '', '', '', c.stations[0].name, c.stations[1].name, c.year, c.yearEnd]);
      });

      var lineSheet = XLSX.utils.aoa_to_sheet(line_data);

      XLSX.utils.book_append_sheet(book, lineSheet, `Line_${l.name}`);
    });

    XLSX.writeFile(book, `${townIdOrName}.xlsx`);
    return;
  }
  catch (err) {
    return { statusCode: 500, data: err };
  }
}

service.importTownData = async (modelsService, user, townIdOrName, fileName) => {
  if (!verifyRoles(['A'], user)) {
    return { statusCode: 401, data: 'Unauthorized' };
  }
  const town = await getTown(modelsService, townIdOrName, false);
  if (!town) {
    return { statusCode: 404, data: 'Town not found' };
  }
  if (!fileName.includes(town.url)) {
    return { statusCode: 400, data: 'File name does not match Town ID' };
  }

  const Draft = modelsService.getModel('Draft');
  const Station = modelsService.getModel('Station');
  const Line = modelsService.getModel('Line');
  const Connection = modelsService.getModel('Connection');
  const stationDocuments = [];

  let draft;
  let oldDraft;

  const getOldDraft = async () => {
    oldDraft = await Draft.findOne({ town: town._id, autogenerated: true });
  }

  const removeOldDraft = async () => {
    if (oldDraft) {
      town.drafts = town.drafts.filter(d => !d._id.equals(oldDraft._id));
      await town.save();

      await Draft.deleteOne({ _id: oldDraft._id });
    }
  }

  const generateDraft = async () => {
    const newDraft = new Draft(
      addCreatedAndModified({
        name: `${town.name}_draft`,
        description: `${town.name} Draft autogenerated`,
        status: 'draft',
        autogenerated: true,
        town: town._id,
        managers: [user._id]
      },
        user,
        true
      )
    );
    draft = await newDraft.save();

    town.drafts.push(draft._id);
    await town.save();

    user.drafts.push(draft._id);
    await user.save();
  }

  const generateStation = async (stationObj) => {
    const stationDocument = new Station(
      addCreatedAndModified(
        {
          draft: draft.id,
          name: stationObj.name,
          year: stationObj.year,
          yearEnd: stationObj.yearEnd,
          geometry: {
            type: 'Point',
            coordinates: [
              stationObj.lat,
              stationObj.lng
            ]
          },
          markerIcon: 'multiple'
        },
        user,
        true
      ));
    return await stationDocument.save();
  }

  const generateLine = async (lineSheet) => {
    const lineDocument = new Line(
      addCreatedAndModified({
        draft: draft.id,
        key: lineSheet[0].key,
        order: lineSheet[0].order,
        name: lineSheet[0].name,
        shortName: lineSheet[0].shortName,
        colour: lineSheet[0].colour,
        fontColour: lineSheet[0].fontColour,
        year: lineSheet[0].lineyear
      },
        user,
        true
      ));
    return await lineDocument.save();
  }

  const generateConnection = async (line, connection, prevConnection, order) => {
    const stationFromName = connection['station_from'] || prevConnection['station_to'];
    const stationA = stationDocuments.find(s => s.name === stationFromName);
    const stationB = stationDocuments.find(s => s.name === connection['station_to']);
    const connectionDocument = new Connection(
      addCreatedAndModified(
        {
          draft: draft.id,
          order: order,
          line: line.id,
          stations: [
            stationA.id,
            stationB.id
          ],
          year: connection['connectionYear'],
          yearEnd: connection['connectionYearEnd'],
          distance: calculateDistance(stationA.geometry.coordinates, stationB.geometry.coordinates)
        },
        user,
        true));
    await connectionDocument.save();

    line.connections.push(connectionDocument._id);
    await line.save();
    stationA.connections.push(connectionDocument._id);
    stationB.connections.push(connectionDocument._id);
    await stationA.save();
    await stationB.save();
  }

  try {
    // Draft
    await getOldDraft();
    await generateDraft();
    const book = XLSX.readFile(fileName);
    // Stations
    if (oldDraft) {
      await Station.deleteMany({ draft: oldDraft.id });
    }
    const stations = XLSX.utils.sheet_to_json(book.Sheets['Stations']);
    for (let st of stations) {
      const stationDocument = await generateStation(st);
      stationDocuments.push(stationDocument);
    }
    // Lines and Connections
    if (oldDraft) {
      await Line.deleteMany({ draft: oldDraft.id });
      await Connection.deleteMany({ draft: oldDraft.id });
    }

    for (let sheetName of Object.keys(book.Sheets)) {
      // Line
      if (sheetName.startsWith('Line_')) {
        const line = await generateLine(XLSX.utils.sheet_to_json(book.Sheets[sheetName]));
        // Line connections
        const connections = XLSX.utils.sheet_to_json(book.Sheets[sheetName]).slice(1);
        for (let i = 0; i < connections.length; i++) {
          await generateConnection(line, connections[i], i > 0 ? connections[i - 1] : null, i + 1);
        }
      }
    }
    // Final calculations
    await service.doCalculations(modelsService, user, draft._id);
    await removeOldDraft();
    return { statusCode: 200, data: 'All data was imported correctly' };
  }
  catch (err) {
    return { statusCode: 500, data: err };
  }
}

service.importTowns = async (modelsService, user) => {
  if (!verifyRoles(['A'], user)) {
    return { statusCode: 401, data: 'Unauthorized' };
  }
  const Town = modelsService.getModel('Town');
  const Country = modelsService.getModel('Country');
  try {
    const book = XLSX.readFile('temp/towns.xlsx');
    const towns = XLSX.utils.sheet_to_json(book.Sheets['Towns']);
    for (let tw of towns) {
      let townDocument = await Town.findOne({ url: tw.url });
      if (!townDocument) {
        townDocument = new Town({});
      }
      townDocument.order = tw.oder;
      townDocument.name = tw.name;
      const country = await Country.findOne({ name: tw.country });
      if (country) {
        townDocument.country = country.id;
      }
      townDocument.url = tw.url;
      townDocument.center = {
        type: 'Point',
        coordinates: [
          tw.lat,
          tw.lng
        ]
      };
      townDocument.zoom = tw.zoom;
      townDocument.year = tw.year;
      townDocument.alias = tw.alias;
      await townDocument.save();
    }
    return { statusCode: 200, data: 'All towns were imported correctly' };
  }
  catch (err) {
    return { statusCode: 500, data: err };
  }
}

service.importCountries = async (modelsService, user) => {
  if (!verifyRoles(['A'], user)) {
    return { statusCode: 401, data: 'Unauthorized' };
  }
  const Country = modelsService.getModel('Country');
  try {
    const book = XLSX.readFile('temp/countries.xlsx');
    const countries = XLSX.utils.sheet_to_json(book.Sheets['Countries']);
    for (let ct of countries) {
      let countryDocument = await Country.findOne({ code: ct.code });
      if (!countryDocument) {
        countryDocument = new Country({});
      }
      countryDocument.code = ct.code;
      countryDocument.name = ct.name;
      countryDocument.continent = ct.continent;
      await countryDocument.save();
    }
    return { statusCode: 200, data: 'All countries were imported correctly' };
  }
  catch (err) {
    return { statusCode: 500, data: err };
  }
}

service.doCalculations = async (modelsService, user, draftId) => {

  if (!verifyRoles(['A'], user)) {
    return { statusCode: 401, data: 'Unauthorized' };
  }

  const Town = modelsService.getModel('Town');
  const Draft = modelsService.getModel('Draft');
  const Line = modelsService.getModel('Line');
  const Station = modelsService.getModel('Station');
  const Connection = modelsService.getModel('Connection');

  // Draft
  const draft = await Draft.findOne({ _id: draftId });
  const linesAmount = await Line.countDocuments({ draft: draftId });
  const stationsAmount = await Station.countDocuments({ draft: draftId });
  const connectionsAmoun = await Connection.countDocuments({ draft: draftId });
  draft.linesAmount = linesAmount;
  draft.stationsAmount = stationsAmount;
  draft.connectionsAmount = connectionsAmoun;
  await draft.save();

  // Lines
  const calculateStationsAndDistanceInLine = async (Line) => {
    const lines = await Line.find({}).populate({ path: 'connections', populate: { path: 'stations', select: 'id' } });
    for (const l of lines) {
      const allStations = [];
      l.distance = 0;
      l.connections.forEach(c => {
        c.stations.forEach(s => allStations.push(s.id));
        l.distance += c.distance;
      });
      l.stationsAmount = getUniqueInArray(allStations).length;
      await l.save();
    }
  }

  calculateStationsAndDistanceInLine(Line);
}



module.exports = service;